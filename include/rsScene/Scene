#ifndef RSSCENE_SCENE_
#define RSSCENE_SCENE_

#include <osg/BoundingBox>
#include <osg/Depth>
#include <osg/LineWidth>
#include <osg/Material>
#include <osg/MatrixTransform>
#include <osg/Point>
#include <osg/ShapeDrawable>
#include <osg/TextureCubeMap>
#include <osgDB/ReadFile>
#include <osgGA/OrbitManipulator>
#include <osgGA/StateSetManipulator>
#include <osgText/Text>
#include <osgShadow/ShadowMap>
#include <osgShadow/ShadowedScene>
#include <osgUtil/SmoothingVisitor>
#include <osgUtil/Optimizer>
#include <osgViewer/Viewer>
#include <osgViewer/ViewerEventHandlers>

#include <rs/Threads>
#include <rsRobots/Linkbot>
#include <rsRobots/Mindstorms>
#include <rsScene/KeyboardHandler>
#include <rsScene/MouseHandler>

extern osg::Node::NodeMask NOT_VISIBLE_MASK;
extern osg::Node::NodeMask RECEIVES_SHADOW_MASK;
extern osg::Node::NodeMask CASTS_SHADOW_MASK;
extern osg::Node::NodeMask IS_PICKABLE_MASK;
extern osg::Node::NodeMask VISIBLE_MASK;

namespace rsScene {

	// typedefs
	typedef osg::Group Obstacle;
	typedef osg::Group Robot;

	// class
	class LIBRSEXPORT Scene : public KeyboardHandler {
		// public functions
		public:
			Scene(void);
			virtual ~Scene(void);

			int addAndRemoveChildren(void);
			void addChildrenToBackground(void);
			void addHighlight(int, bool = true, bool = true, const rs::Vec& = rs::Vec(1, 1, 0));
			int deleteObstacle(int);
			int deleteRobot(int);
			void drawConnector(rsRobots::ModularRobot*, Robot*, int, int, int, double, int, int);
			int drawMarker(int, int, const rs::Pos&, const rs::Pos&, const rs::Vec&, int, std::string);
			Obstacle* drawObstacle(int, int, const rs::Pos&, const rs::Vec&, const rs::Vec&, const rs::Quat&);
			Robot* drawRobot(rsRobots::Robot*, const rs::Pos&, const rs::Quat&, const rs::Vec&, const rs::Vec&, bool);
			void drawWheel(rsRobots::Robot*, Robot*, int, int);
			osgText::Text* getHUDText(void);
			std::string getTexturePath(void);
			void setBackgroundImage(int, std::string);
			void setGrid(std::vector<double>, bool = false);
			void setHighlight(bool);
			void setHUD(bool);
			void setLabel(bool);
			void setLevel(int);
			void setMouseHandler(rsScene::MouseHandler*);
			void setPauseText(int);
			void setUnits(bool);
			int setupCamera(osg::GraphicsContext*, double, double);
			int setupScene(double, double, bool);
			int setupViewer(osgViewer::Viewer*);
			void start(int);
			void toggleHighlight(osg::Group*, osg::Node*, const rs::Vec& = rs::Vec(1, 1, 0), bool = false);
			void toggleLabel(osg::Group*, osg::Node*);

		// virtual functions for inherited classes
		protected:
			virtual void keyPressed(int) {};

		// private functions
		private:
			osg::Material* create_material(osg::Vec4);
			void draw_grid(double, double, double, double, double, double, double);
			void draw_global_hud(double, double, bool);
			void draw_robot_linkbot(rsRobots::Linkbot*, Robot*, const rs::Pos&, const rs::Quat&, const rs::Vec&, const rs::Vec&, bool);
			void draw_robot_linkbot_conn(rsRobots::Linkbot*, Robot*, int, int, int, double, int, int);
			void draw_robot_mindstorms(rsRobots::Mindstorms*, Robot*, const rs::Pos&, const rs::Quat&, const rs::Vec&, const rs::Vec&, bool);
			void draw_robot_mindstorms_wheel(rsRobots::Mindstorms*, Robot*, int, int);
			void draw_scene_outdoors(void);
			void draw_scene_board(void);
			void draw_skybox(void);
			static void* graphics_thread(void*);
			bool intersect_new_item(int id, const osg::BoundingBox&);

		// private data
		private:
			bool _highlight;					// flag: enable object highlight on click
			bool _label;						// flag: enable object hud on click
			bool _thread;						// flag: thread is running
			bool _units;						// flag: SI (true) or customary (false)
			int _level;							// level to load
			osg::Camera *_camera;				// camera to view scene
			osg::Group *_background;			// pieces of each level which are interchangeable
			osg::Group *_root;					// root node of scene
			osg::Group *_staging[2];			// temp variable for adding objects
			osgViewer::Viewer *_viewer;			// viewer
			osgShadow::ShadowedScene *_scene;	// shadow root of scene
			std::string _model_path;			// path for 3ds models
			std::vector<double> _grid;			// grid
			std::vector<std::string> _path;		// image paths
			MUTEX_T _thread_mutex;				// mutex: thread running state
			THREAD_T _osgThread;				// thread: graphics window
	};

} // namespace rsScene

#endif // RSSCENE_SCENE_

