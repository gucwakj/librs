#ifndef RSSCENE_SCENE_
#define RSSCENE_SCENE_

#include <rs/Threads>
#include <rsScene/KeyboardHandler>
#include <rsScene/MouseHandler>
#include <rsScene/Robot>

extern osg::Node::NodeMask NOT_VISIBLE_MASK;
extern osg::Node::NodeMask RECEIVES_SHADOW_MASK;
extern osg::Node::NodeMask CASTS_SHADOW_MASK;
extern osg::Node::NodeMask IS_PICKABLE_MASK;
extern osg::Node::NodeMask VISIBLE_MASK;

namespace osg {
	class Camera;
	class Group;
	class Material;
}

namespace osgShadow {
	class ShadowedScene;
}

namespace osgText {
	class Text;
}

namespace osgViewer {
	class Viewer;
}

namespace rsScene {

	// typedefs
	typedef osg::Group Obstacle;

	// class
	class LIBRSEXPORT Scene : public KeyboardHandler {
		// public functions
		public:
			Scene(void);
			virtual ~Scene(void);

			void addAndRemoveChildren(bool = false);
			void addChildrenToBackground(void);
			void addHighlight(int, bool = false, bool = true, bool = true, const rs::Vec& = rs::Vec(1, 1, 0));
			Group* createPreconfig(int);
			Group* createRobot(rsScene::Robot*);
			int deleteMarker(int);
			int deleteObstacle(int);
			int deletePreconfig(int);
			int deleteRobot(int);
			int drawMarker(int, int, const rs::Pos&, const rs::Pos&, const rs::Vec&, int, std::string);
			Obstacle* drawObstacle(int, int, const rs::Pos&, const rs::Vec&, const rs::Vec&, const rs::Quat&);
			osgText::Text* getHUDText(void);
			std::string getTexturePath(void);
			void reidRobot(int);
			void setBackgroundImage(int, std::string);
			void setFrameRate(int);
			void setGrid(std::vector<double>, bool = false);
			void setHighlight(bool);
			void setHUD(bool);
			void setLabel(bool);
			void setLevel(int);
			void setMouseHandler(rsScene::MouseHandler*);
			void setPauseText(int);
			void setRobotCallback(osg::Group*, osg::NodeCallback*);
			void setUnits(bool);
			int setupCamera(osg::GraphicsContext*, double, double);
			int setupScene(double, double, bool);
			int setupViewer(osgViewer::Viewer*);
			void stageChild(osg::Group*);
			void start(int);
			void toggleHighlight(osg::Group*, osg::Node*, const rs::Vec& = rs::Vec(1, 1, 0), bool = false);
			void toggleLabel(osg::Group*, osg::Node*);

		// virtual functions
		protected:
			virtual void keyPressed(int) {};

		// private functions
		private:
			osg::Material* create_material(osg::Vec4);
			void draw_grid(double, double, double, double, double, double, double);
			void draw_board(double, double);
			void draw_ground(void);
			void draw_hud(double, double, bool);
			void draw_skybox(void);
			static void* graphics_thread(void*);
			bool intersect_new_item(int id, const osg::BoundingBox&);

		// private data
		private:
			bool _graphics;						// flag: graphics setup ready
			bool _highlight;					// flag: enable object highlight on click
			bool _label;						// flag: enable object hud on click
			bool _thread;						// flag: thread is running
			bool _units;						// flag: SI (true) or customary (false)
			int _level;							// level to load
			int _rate;							// desired frame rate
			osg::Camera *_camera;				// camera to view scene
			osg::Group *_background;			// pieces of each level which are interchangeable
			osg::Group *_root;					// root node of scene
			osg::Group *_staging[3];			// temp variable for adding objects
			osgViewer::Viewer *_viewer;			// viewer
			osgShadow::ShadowedScene *_scene;	// shadow root of scene
			std::string _tex_path;				// path to texture objects
			std::vector<double> _grid;			// grid
			std::vector<std::string> _path;		// image paths
			RS_COND_T _graphics_cond;			// condition: graphics setup waiting
			RS_MUTEX_T _thread_mutex;			// mutex: thread running state
			RS_MUTEX_T _graphics_mutex;			// mutex: graphics setup complete
			RS_THREAD_T _osgThread;				// thread: graphics window
	};

} // namespace rsScene

#endif // RSSCENE_SCENE_

