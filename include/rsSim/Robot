#ifndef RSSIM_ROBOT_
#define RSSIM_ROBOT_

#include <ode/ode.h>

#include <config.h>
#include <rs/Threads>
#include <rs/Pos>
#include <rs/Quat>
#include <rs/Vec>
#include <rsRobots/Robot>

namespace rsSim {

	// forward declarations
	class Sim;

	// typedefs
	typedef std::vector<dBodyID> BodyList;

	// class
	class LIBRSEXPORT Robot : virtual public rsRobots::Robot {
		// public functions
		public:
			Robot(void);
			virtual ~Robot(void);

			virtual double getAngle(int);
			int holdJoint(int);
			int holdJoints(void);
			int moveJoint(int, double);
			int moveJointNB(int, double);
			int moveJointTo(int, double);
			int moveJointToNB(int, double);
			int moveJointWait(int);
			int pauseWait(void);
#ifdef RS_RESEARCH
			void setCPGGoal(double);		// research: set next goal value
#endif
			int addToSim(dWorldID&, dSpaceID&, int, rsSim::Sim*);
			virtual int build(const rs::Pos&, const rs::Quat&, const rs::Vec&, const rs::Vec&, int) { return 0; };
			BodyList& getBodyList(void) { return _body; };
			double getCenter(int);
			const rs::Pos getPosition(void);
			const rs::Quat getQuaternion(void);
			virtual const rs::Pos getCoM(double &mass) { mass = 0; return rs::Pos(); };
			static void* simPreCollisionThreadEntry(void*);
			static void* simPostCollisionThreadEntry(void*);

		// protected functions
		protected:
			int doze(double);
			int fixBodyToGround(dBodyID);
			virtual dBodyID getBodyID(short id) { return _body[id]; };
			double getRotation(int, int);
			double mod_angle(double, double, double);
			short noisy(float*, short, float);
			virtual void simPreCollisionThread(void) { return; };
			virtual void simPostCollisionThread(void) { return; };

		// protected data
		protected:
			// motor motion directions
			typedef enum motor_state_e {
				NEUTRAL,				// non actuated
				HOLD,					// hold at current angle
				POSITIVE,				// move in positive direction
				NEGATIVE,				// move in negative direction
			} motorState_t;
			// motor motion profiles
			typedef enum motor_mode_e {
				ACCEL_CONSTANT,			// do a constant acceleration
				ACCEL_CYCLOIDAL,		// follow a cycloidal accel curve
				ACCEL_HARMONIC,			// follow a harmonic accel curve
				CONTINUOUS,				// turn on and stay on
				SEEK,					// seek a new joint angle
				SINGULAR,				// research: move one value each timestep
			} motorMode_t;

			// motor accelerations
			struct Accel {
				float init;				// motion initial angle
				float start;			// motion start time
				float period;			// motion period
				short run;				// number of motions
			};
			// motor
			struct Motor {
				bool success;			// trigger for motion completion
				bool record;			// recording in progress
				bool record_active;		// actively recording a new point
				double **record_angle;	// recording angles from thread
				float alpha;			// angular acceleration
				float encoder;			// encoder resolution
				float goal;				// goal theta value
				float offset;			// offset from zero for resetting
				float omega;			// angular rate
				float omega_max;		// maximum rate
				float safety_angle;		// safety angle
				float safety_timeout;	// safety timeout
				float tau_max;			// maximum force
				float theta;			// theta
				int record_num;			// recording points
				short mode;				// modes
				short starting;			// starting movement
				short state;			// state
				short stopping;			// stopping movement
				short timeout;			// mode timeout
				dJointID id;			// motor id
				dJointID joint;			// joint of the motor
				Accel accel;			// acceleration variables
				RS_MUTEX_T success_mutex;	// motion successful mutex
				RS_COND_T success_cond;	// motion successful condition
			};

			dSpaceID _space;			// space for this robot
			dWorldID _world;			// world for all robots
			rsSim::Sim *_sim;			// simulation instance
			std::vector<Motor> _motor;	// motors
			BodyList _body;				// body parts
			bool _success;				// all joints are done
			bool _connected;			// connected to controller
			float _accel[3];			// accelerometer
#ifdef RS_RESEARCH
			float _next_goal;			// research: next value to hit
			bool _start;				// research: starting simulation
#endif
			float _speed;				// linear velocity of the robot
			float _trackwidth;			// trackwidth of robot
			short _dof;					// number of DOF
			RS_MUTEX_T _goal_mutex;		// goal value being written
			RS_MUTEX_T _pause_mutex;	// simulation is paused
			RS_MUTEX_T _success_mutex;	// completed step
			RS_MUTEX_T _theta_mutex;	// theta value being written
			RS_COND_T _pause_cond;		// finish pausing
			RS_COND_T _success_cond;	// completed step

		// private functions
		private:
			float normal(float);
			float uniform(void);

		// private data
		private:
			short _seed;				// seed for random number generation
	};

} // namespace rsSim

#endif // RSSIM_ROBOT_

