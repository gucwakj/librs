#ifndef RSSIM_ROBOT_HPP_
#define RSSIM_ROBOT_HPP_

#include <ode/ode.h>

#include <rs/Macros>
#include <rs/Pos>
#include <rs/Quat>
#include <rsRobots/Robot>

namespace rsSim {

	// forward declarations
	class Sim;

	// typedefs
	typedef std::vector<dBodyID> BodyList;

	// class
	class Robot : virtual public rsRobots::Robot {
		// public functions
		public:
			Robot(void);
			virtual ~Robot(void);

			int holdJoint(int);
			int holdJoints(void);
			int moveJoint(int, double);
			int moveJointNB(int, double);
			int moveJointTo(int, double);
			int moveJointToNB(int, double);
			int moveJointWait(int);
			int moveNB(double*);
			int moveToNB(double*);
			int moveWait(void);
			int setJointSpeed(int, double);
			int setJointSpeedRatio(int, double);
			int addToSim(dWorldID&, dSpaceID&, int, int, rsSim::Sim*);
			virtual int build(const rs::Pos&, const rs::Quat&, const double*, int) { return 0; };
			virtual double getAngle(int) { return 0; };
			BodyList& getBodyList(void);
			double getCenter(int);
			const rs::Pos getPosition(void);
			const rs::Quat getQuaternion(void);
			virtual void getCoM(double&, double&, double&) { return; };
			static void* simPreCollisionThreadEntry(void*);
			static void* simPostCollisionThreadEntry(void*);

		// utility functions
		protected:
			double convert(double, int);
			int doze(double);
			int fixBodyToGround(dBodyID);
			dBodyID getBodyID(int);
			double getRotation(int, int);
			double mod_angle(double, double, double);
			int noisy(double*, int, double);
			virtual int buildIndividual(const rs::Pos&, const rs::Quat&, const double*) { return 0; };
			virtual void init_params(void) { return; };
			virtual void simPreCollisionThread(void) { return; };
			virtual void simPostCollisionThread(void) { return; };

		// data members
		protected:
			// motor motion directions
			typedef enum motor_state_e {
				NEUTRAL,
				HOLD,
				POSITIVE,
				NEGATIVE,
			} motorState_t;
			// motor motion profiles
			typedef enum motor_mode_e {
				ACCEL_CONSTANT,
				ACCEL_CYCLOIDAL,
				ACCEL_HARMONIC,
				CONTINUOUS,
				SEEK,
			} motorMode_t;

			// motor accelerations
			struct Accel {
				double init;		// motion initial angle
				double start;		// motion start time
				double period;		// motion period
				double run;			// number of motions
			};
			// motor
			struct Motor {
				bool success;			// trigger for motion completion
				bool record;			// recording in progress
				bool record_active;		// actively recording a new point
				double alpha;			// angular acceleration
				double encoder;			// encoder resolution
				double goal;			// goal theta value
				double offset;			// offset from zero for resetting
				double omega;			// angular rate
				double omega_max;		// maximum rate
				double **record_angle;	// recording angles from thread
				double safety_angle;	// safety angle
				double safety_timeout;	// safety timeout
				double tau_max;			// maximum force
				double theta;			// theta
				int mode;				// modes
				int record_num;			// recording data points
				int starting;			// starting movement
				int state;				// state
				int stopping;			// stopping movement
				int timeout;			// mode timeout
				dJointID id;			// motor id
				dJointID joint;			// joint of the motor
				Accel accel;			// acceleration variables
				MUTEX_T success_mutex;	// motion successful mutex
				COND_T success_cond;	// motion successful condition
			};

			dSpaceID _space;			// space for this robot
			dWorldID _world;			// world for all robots
			rsSim::Sim *_sim;			// simulation instance
			std::vector<Motor> _motor;	// motors
			BodyList _body;				// body parts
			bool _motion;				// motion in progress
			double _accel[3];			// accelerometer data
			double _center[3];			// offset of body from initial (x,y,z)
			double _distOffset;			// offset for recorded distance
			double _radius;				// radius of wheels
			double _speed;				// linear velocity of the robot
			double _trackwidth;			// trackwidth of robot
			int _connected;				// connected to controller
			int _dof;					// number of DOF
			int _pos;					// position in simulation
			int _seed;					// seed for random number generation
			MUTEX_T _goal_mutex;		// goal value being written
			MUTEX_T _success_mutex;		// completed step
			COND_T _success_cond;		// completed step
			MUTEX_T _theta_mutex;		// theta value being written

		// private functions
		private:
			double normal(double);
			double uniform(void);
	};

} // namespace rsSim

#endif // RSSIM_ROBOT_HPP_

