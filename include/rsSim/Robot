#ifndef RSSIM_ROBOT_
#define RSSIM_ROBOT_

#include <ode/ode.h>

#include <rs/Threads>
#include <rs/Pos>
#include <rs/Quat>
#include <rs/Vec>
#include <rsRobots/Robot>

namespace rsSim {

	// forward declarations
	class Sim;

	// typedefs
	typedef std::vector<dBodyID> BodyList;

	// class
	class LIBRSEXPORT Robot : virtual public rsRobots::Robot {
		// public functions
		public:
			Robot(void);
			virtual ~Robot(void);

			double getAngle(int);
			int holdJoint(int);
			int holdJoints(void);
			int moveJoint(int, double);
			int moveJointNB(int, double);
			int moveJointTo(int, double);
			int moveJointToNB(int, double);
			int moveJointWait(int);
			int moveWait(void);
			void setCPGGoal(double);		// research: set next goal value
			int addToSim(dWorldID&, dSpaceID&, int, rsSim::Sim*);
			virtual int build(const rs::Pos&, const rs::Quat&, const rs::Vec&, const rs::Vec&, int) { return 0; };
			BodyList& getBodyList(void);
			double getCenter(int);
			const rs::Pos getPosition(void);
			const rs::Quat getQuaternion(void);
			virtual const rs::Pos getCoM(double &mass) { mass = 0; return rs::Pos(); };
			static void* simPreCollisionThreadEntry(void*);
			static void* simPostCollisionThreadEntry(void*);

		// utility functions
		protected:
			virtual double calculate_angle(int) { return 0; };
			int doze(double);
			int fixBodyToGround(dBodyID);
			virtual dBodyID getBodyID(int);
			double getRotation(int, int);
			double mod_angle(double, double, double);
			int noisy(double*, int, double);
			virtual int buildIndividual(const rs::Pos&, const rs::Quat&, const rs::Vec&) { return 0; };
			virtual void simPreCollisionThread(void) { return; };
			virtual void simPostCollisionThread(void) { return; };

		// data members
		protected:
			// motor motion directions
			typedef enum motor_state_e {
				NEUTRAL,				// non actuated
				HOLD,					// hold at current angle
				POSITIVE,				// move in positive direction
				NEGATIVE,				// move in negative direction
			} motorState_t;
			// motor motion profiles
			typedef enum motor_mode_e {
				ACCEL_CONSTANT,			// do a constant acceleration
				ACCEL_CYCLOIDAL,		// follow a cycloidal accel curve
				ACCEL_HARMONIC,			// follow a harmonic accel curve
				CONTINUOUS,				// turn on and stay on
				ONCE,					// research: follow array of values
				SEEK,					// seek a new joint angle
				SINGULAR,				// research: move one value each timestep
			} motorMode_t;

			// motor accelerations
			struct Accel {
				double init;			// motion initial angle
				double start;			// motion start time
				double period;			// motion period
				double run;				// number of motions
			};
			// motor
			struct Motor {
				bool success;			// trigger for motion completion
				bool record;			// recording in progress
				bool record_active;		// actively recording a new point
				double alpha;			// angular acceleration
				double encoder;			// encoder resolution
				double goal;			// goal theta value
				double offset;			// offset from zero for resetting
				double omega;			// angular rate
				double omega_max;		// maximum rate
				double **record_angle;	// recording angles from thread
				double safety_angle;	// safety angle
				double safety_timeout;	// safety timeout
				double tau_max;			// maximum force
				double theta;			// theta
				int mode;				// modes
				int record_num;			// recording data points
				int starting;			// starting movement
				int state;				// state
				int stopping;			// stopping movement
				int timeout;			// mode timeout
				dJointID id;			// motor id
				dJointID joint;			// joint of the motor
				Accel accel;			// acceleration variables
				MUTEX_T success_mutex;	// motion successful mutex
				COND_T success_cond;	// motion successful condition
			};

			dSpaceID _space;			// space for this robot
			dWorldID _world;			// world for all robots
			rsSim::Sim *_sim;			// simulation instance
			std::vector<Motor> _motor;	// motors
			BodyList _body;				// body parts
			bool _motion;				// motion in progress
			double _accel[3];			// accelerometer data
			double _center[3];			// offset of body from initial (x,y,z)
			double _distOffset;			// offset for recorded distance
			double _next_goal;			// research: next value to hit
			double _speed;				// linear velocity of the robot
			double _trackwidth;			// trackwidth of robot
			int _connected;				// connected to controller
			int _dof;					// number of DOF
			MUTEX_T _goal_mutex;		// goal value being written
			MUTEX_T _success_mutex;		// completed step
			MUTEX_T _theta_mutex;		// theta value being written
			COND_T _success_cond;		// completed step

		// private functions
		private:
			double normal(double);
			double uniform(void);

		// private variables
		private:
			int _seed;					// seed for random number generation
	};

} // namespace rsSim

#endif // RSSIM_ROBOT_

