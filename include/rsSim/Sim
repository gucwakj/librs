#ifndef RSSIM_SIM_
#define RSSIM_SIM_

#include <vector>

#include <rs/Enum>
#include <rs/Quat>
#include <rsSim/ModularRobot>
#include <rsSim/Robot>

#ifdef RS_RESEARCH
#include <rsResearch/Integrator>
#endif

namespace rsSim {

	// typedefs
	typedef dBodyID Obstacle;

	// class
	class LIBRSEXPORT Sim {
		// public functions
		public:
			Sim(bool, bool);
			virtual ~Sim(void);

			void addRobot(Robot*, short, const rs::Pos&, const rs::Quat&, const rs::Vec&, const rs::Vec& = rs::Vec(0,0), short = -1);
			void addRobot(ModularRobot*, short, Robot*, const rs::Vec&, short, short, short, short, short = rs::Right, short = -1);
			Obstacle* addCompetitionBorder(const rs::Pos&, const rs::Quat&, const rs::Vec&);
			Obstacle* addObstacle(const rs::Pos&, const rs::Quat&, const rs::Vec&, double);
			Obstacle* addObstacle(const rs::Pos&, const rs::Quat&, const rs::Vec&, double, int);
			Obstacle* addObstacle(const rs::Pos&, const rs::Vec&, double);
			Obstacle* addPullupBar(const rs::Pos&, const rs::Quat&, const rs::Vec&);
			virtual int deleteRobot(int);
			float getClock(void);
			void getCoM(double&, double&, double&);
			bool getPause(void);
			Robot* getRobot(int);
			bool getRunning(void);
			float getStep(void);
			void mutexLock(int);
			void mutexUnlock(int);
			void run(unsigned int);
#ifdef RS_RESEARCH
			void setCPG(int(*)(double, const double*, double*, void*), struct rsResearch::Params*);		// research
#endif
			void setCollisions(int);
			void setPause(int);

		// public enumerations
		public:
			enum Mutexes {
				AddRobot,
				PauseSimulation,
				RunningSimulation
			};

		// private functions
		private:
			static void collision(void*, dGeomID, dGeomID);	// wrapper function for nearCallback to work in class
			static void* simulation_thread(void*);			// simulation thread function

		// private data
		private:
			struct RobotNode {
				rsSim::Robot *robot;
				RS_THREAD_T thread;
			};

			bool _collision;					// flag: perform collisions
			bool _running;						// flag: simulation running
			bool _rt;							// flag: run in real time
			bool _pause;						// flag: paused
			float _clock;						// clock time of simulation
			float _friction[2];					// coefficient of friction [body/ground, body/body]
			float _restitution[2];				// coefficient of restitution [body/ground, body/body]
			float _step;						// time step of simulation
			float _stop;						// time to stop simulation
			dWorldID _world;					// ode: world
			dSpaceID _space;					// ode: space for robots
			dJointGroupID _group;				// ode: joint group
			std::vector<RobotNode> _robot;		// list: robots
			RS_COND_T _running_cond;			// condition: actively running simulation
			RS_MUTEX_T _clock_mutex;			// mutex: getting the clock
			RS_MUTEX_T _pause_mutex;				// mutex: paused simulation
			RS_MUTEX_T _robot_mutex;				// mutex: ground collisions
			RS_MUTEX_T _running_mutex;				// mutex: actively running program
			RS_MUTEX_T _step_mutex;				// mutex: getting the step value
			RS_THREAD_T _simulation;				// thread: simulation
#ifdef RS_RESEARCH
			rsResearch::Integrator _integ;		// research: integrator class
#endif
	};

} // namespace rsSim

#endif // RSSIM_SIM_

